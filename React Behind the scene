React work Behind efficiently uses diff alorithm to find out the differnece between old virtaul DOM and virtual DOM it create during updating and update the differnece.

=====================================================================================================================================================

                                        COMPONENT vs INSTANCES vs ELEMENT

COMPOENENTS:
1. Description of a piece of a UI
2. A component is a function that return React elements (element Tree), Usually written as JSX.
3. you can call "BluePrint" or "Template"
4. Exmple:
                                                funtion Tabs ({ items }) {
                                                  return (
                                                      <div className="tab-content">
                                                        <h4>All contacts</h4>
                                                        <p>Your post will be visible</p>
                                                      </div>
                                                    );
                                                  }


COMPONENT INSTANCES:
when we call or use component multiple time in our app than it become instances of that component.
1. Example:
                                                funtion App () {
                                                  return (
                                                      <> // it create three instances of Tab component
                                                        <Tabs items={content[0]}/>
                                                        <Tabs items={content[1]}/>
                                                        <Tabs items={content[2]}/>
                                                      </>
                                                    );
                                                  }
2. Instance are created when we use the components
3. Actual physical "menifestion" of a components.
4. Each instance will have its own state, props.
5. each instance will have own lifecycle.

ELEMENTS:
React execute each instances and each of them will return own one or more react elements.
1. JSX Convert to React.creatElement() function call.
2. A react element is the result of these funcntion calls.
3. Information necessary to create DOM element.
4. Example:
                                                            function Tabs({ items }) {
                                                              return React.createElement(
                                                                'div',
                                                                { className: 'tab-content' },
                                                                React.createElement('h4', null, 'All contacts'),
                                                                React.createElement('p', null, 'Your post will be visible')
                                                              );
                                                            }


Component -------> Compoenent Instance ------> React Elements -----> DOM Element (HTML) -----> Painted onto the screen by browser

call component as <MyComponent />
but not like this MyComponent() XXX reason react will not look this like a component instance will not be inside component tree, 
                                    and independent state of this component will move inside parent component

=========================================== VITUAL DOM ========================================================================================
It uses Viratual DOM: It is a representation of actual DOM in objects.
In Virtual DOM when a parent component update than all its children component will also update as well
VIRTUAL DOM REPRESENTATION:

// Simplified Fiber node structure
const fiberNode = {
  type: 'div',
  props: { className: 'container' },
  child: null,      // First child
  sibling: null,    // Next sibling
  return: null,     // Parent
  alternate: null,  // Previous version for comparison
  effectTag: null,  // What kind of work needs to be done
  expirationTime: 0 // When this work expires
};

========================================================================================================================================================
It work in three phase.

Phase 1: 
Initail Rendering and State change:
  React create a virtual represntation of our Component tree. when state changes or update occur on UI, react create a new virtual DOM tree.

Phase 2:
Diffing Algorithm:
  React compare(Differnce) the new Virtual DOM tree with the previous one.

Phase 3:
Re-conciliation: Deciding Which DOM Elements actually need to be inserted, deleted or updated, in order to reflect the latest state change.

=======================================================================================================================================================

Eaxmple:
                                                // When this state changes...
                                                  const [count, setCount] = useState(0);
                                                  
                                                  // React creates a new Virtual DOM representation
                                                  return (
                                                    <div>
                                                      <h1>Count: {count}</h1>  // Only this text node gets updated
                                                      <button onClick={() => setCount(count + 1)}>
                                                        Increment
                                                      </button>
                                                    </div>
                                                  );

When count changes from 0 to 1, React doesn't re-create the entire div, h1, or button elements. It only updates the text content inside the h1 tag.

======================================================================================================================================================

Feature of React Fibre in react working:
1. The goal of react fibre is to increase its sustainbility.

=======================================================================================================================================================

2. It's main feature is Incremental Rendering means "The ability to split rendering work into chunks and spread it 
    out over multiple frame rather than blocking the main thread with one large rendering operation."

================================================== THE PROBLEM SOLVE BY INCREMENTAK RENDERING ======================================================
    
      In traditional React (before React 16), when a component tree needed to update, React would:
    1. Start at the root and work its way down
    2. Process the entire component tree in one synchronous operation
    3. Block the main thread until all work was complete

      This could cause performance issues like:
    1. Janky animations
    2. Unresponsive user interactions
    3. Dropped frames (below 60fps)

============================================================ How Incremental Rendering Works =============================================================
    React breaks rendering work into units of work that can be:
        1. Paused: Stop mid-way through rendering
        2. Resumed: Continue where it left off
        3. Prioritized: Handle high-priority work first
        4. Discarded: Abandon work if it becomes irrelevant

                The Fiber reconciler can:
                        1. Track work in progress
                        2. Assign priorities to different types of updates
                        3. Interrupt and resume work as needed
This is different from the old "stack reconciler" which had to complete all work synchronously once started. 
The key insight is that React now treats rendering as interruptible work rather than an atomic operation, 
leading to much smoother and more responsive applications.

=================================================================================================================================================

3. Other key features include the ability to pause, abort, or reuse work as new updates come in; 
    the ability to assign priority to different types of updates; and new concurrency primitives.

ABILITY TO PAUSE:
Eaxmple:

                                                // React can pause mid-render if something more urgent comes up
                                                function ExpensiveComponent() {
                                                  // React might pause here if a user interaction occurs
                                                  const expensiveCalculation = useMemo(() => {
                                                    return heavyComputation(); // This could be paused
                                                  }, [data]);
                                                  
                                                  return <div>{expensiveCalculation}</div>;
                                                }

ABORT WORK:
Example:
                                                function SearchResults({ query }) {
                                                  const [results, setResults] = useState([]);
                                                  
                                                  useEffect(() => {
                                                    // If user types again while this is rendering,
                                                    // React can abort the previous render work
                                                    fetchResults(query).then(setResults);
                                                  }, [query]);
                                                  
                                                  return results.map(result => <Result key={result.id} data={result} />);
                                                }

REUSE WORK:
Example:

                                                  // If the same component renders with same props,
                                                  // React can reuse previous work instead of recalculating
                                                  const MemoizedExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
                                                    // This work can be reused if data hasn't changed
                                                    const processedData = processExpensiveData(data);
                                                    return <div>{processedData}</div>;
                                                  });

PRIORITY ASSIGNMENT:
Fiber assigns different priorities to different types of updates:

                                                    function App() {
                                                      const [count, setCount] = useState(0);
                                                      const [background, setBackground] = useState('white');
                                                      
                                                      const handleClick = () => {
                                                        // HIGH PRIORITY - User interaction
                                                        setCount(c => c + 1);
                                                        
                                                        // LOW PRIORITY - Visual effect
                                                        startTransition(() => {
                                                          setBackground(count % 2 ? 'blue' : 'red');
                                                        });
                                                      };
                                                      
                                                      return (
                                                        <div style={{ background }}>
                                                          <button onClick={handleClick}>Count: {count}</button>
                                                        </div>
                                                      );
                                                    }

Priority Levels in Fiber:
  1. Immediate Priority: Sync updates (like controlled inputs)
  2. User-Blocking Priority: User interactions (clicks, hovers)
  3. Normal Priority: Network responses, timers
  4. Low Priority: Background tasks
  5. Idle Priority: Non-essential work

NEW CONCURRENCY PRIMITIVES
These are the APIs that leverage Fiber's capabilities:
      1. <Suspense></Suspense> {can Suspend rendering}
      2. startTransition method { Can refer to non-urgent task}, etc

==================================================================================================================================

React never touch the DOM, React only render, it will never know about where will this data will display.
Its ReactDOM which commit on the brower what react render on updation of state, not React

==================================================================================================================================

Initial commit or update of component ==> Render phase ==> Commit phase

RENDER PHASE:

update React Element -> create new virtual DOM + current Fiber tree -> use reconciliation+diff -> updated fibre tree -> list of DOM updated 
this reconciliation is done by re-conciler which work with immutuable data sturcture called fibre tree, in this tree for each react element there is a 
fibre which hold data + queue execution of that node, this queue will update the DOM element and this happen using diffing algorithm.

This render pahse is asynchronous means it can paused, resume, abort component accoding to there importance

COMMIT Phase: 
all list of DOM will shown on UI

this commit phase will be done synchronously, to keep ui consitance

=================================================================================================================================

HOW DIFFING WORK:
work on 2 assumptions:
1. two elements of differnt types will produce different trees
2. Element with stable key prop stays the same across render

Diffing algo work in 2 senario

1. Same position, Differnet element
eaxmple:

<div>                                  <header>
  <SearchBar />        ==>                <SearchBar />   
</div>                                 </header>
<div>...</div>                         <div>...</div>

In above senario,
react assumes entire sub-tree is no longer valid
old component will destryed and removed from DOM, including state
tree might be rebuilt if children stayed same

2. same position same element

example

<div className = "hidden">                                  <div className="active">
  <SearchBar />                      ==>                        <SearchBar />   
</div>                                                      </div>
<div>...</div>                                              <div>...</div>

In above senario,
Element will kept, including state
New props/attributes will passed if they changed between render
Sometime this is not what we want... Then we use the key props
                                          


